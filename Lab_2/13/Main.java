//13. Дан целочисленный двумерный массив размера M×N, заполненный построчно случайными значениями в диапазоне от -99 до 99.
// Этот массив вывести на экран.
//Заменить исходный массив новым, в котором продублирован (вставлен рядом) столбец, содержащий максимальный элемент исходного массива.
// Если таких столбцов несколько, то нужно продублировать последний из них. Получившийся массив вывести на экран.
// М и N задаются в main()
import java.util.Random;
public class Main {

//метод, создающий двумерный массив:
//на вход подаются размеры будущего массива, на выходе получаем получившийся массив
    static int[][] create (int sz1, int sz2)
    {
        int x[][]; // создадим переменную x, хранящую адрес места в памяти, где будет храниться массив ссылочных перменных
        x = new int[sz1][]; // создадим массив ссылочных переменных (в нашем случае размерностью M)
        int i;
        for (i = 0; i < x.length; i++) //создадим массивы (в нашем случае размерностью N), на которые будут указывать ссылочные перменные
            x[i] = new int[sz2];
        return x; //вернем получившийся массив
    }

//метод, инициализирующий двумерный массив:
//на вход подается массив размерностью M на N, на выходе ничего не получаем
    static void init (int x[][])
    {
        Random r = new Random(); // создадим переменню r, хранящую рандомное число
        int i, j;
        for (i = 0; i < x.length; i++) // заполним наш массив рандомными числами, ограничивая диапазон до [-99, 99]
            for (j = 0; j < x[i].length; j++)
                x[i][j] = r.nextInt() % 10;
    }

//метод, выводящий двумерный массив:
//на вход подается массив размерностью M на N, на выходе ничего не получаем
    static void print (int x[][])
    {
        for (int a[] : x) // с помощью коллекций делаем перебор и выводим поэлементно массив (форматируя вывод чисел)
        {
            for (int p : a)
                System.out.printf("%5d", p);
            System.out.println();
        }
    }

//метод, находящий номер столбца (j) максимального элемента массива:
//на вход подается массив размерностью M на N, на выходе получаем номер столбца
    static int maxem (int x[][])
    {
        int maxi = x[0][0]; // задаем изначальный максимум в массиве (пусть это будет первый элемент в массиве)
        int j_i = 0; // задаём j_i перемнную с соотвествующим номером стобца, отвечающую за номер столбца максимального элемента массива
        int i, j;
        for (i = 0; i < x.length; i++) // идем по массиву, сравнивая каждый элемент с максимумом
            for (j = 0; j < x[i].length; j++)
            {
                maxi = (x[i][j] >= maxi)?(x[i][j]):(maxi); //если элемент больше максмума, то максимуму присваиваем значение элемента, иначае оставляем изначальное
                j_i = (x[i][j] >= maxi)?(j):(j_i); //если элемент больше максмума, то j_i присваиваем значение j, иначае оставляем изначальное
            }
        return j_i; // возвращаем номер столбца максимального элемента массива
    }


//метод, создающий расширенный массив с дублированным столбцом
//на вход подается массив размерностью M на N и номер столбца, который мы должны продублировать, на выходе получаем массив с дублированным столбцом
    static void addj (int x[][], int j_i)
    {
        int i,j;
        for (i = 0; i < x.length; i++) // идем по строкам:
        {
            int k[] = new int[x[i].length+1]; // создадим одномерный массив k, в который будем копировать элементы каждой строки

            for (j = 0; j <= j_i; j++) // идем по i строке и копируем элементы, начиная с первого по элменет с индекосм j_i:
            {
                k[j] = x[i][j]; // в массив k в элемент [j] кладем элемент [i][j] изначального массива (то есть копируем один в один)
            }

            k[j_i+1] = x[i][j_i]; // в  массив k в элемент [j_i+1] кладем элемент [i][j_i] изначального массива (то есть дублируем столбец справа)

            for (j = j_i; (j+2) <k.length; j++) // идем по i строке и копируем элементы, начиная с элменета с индекосм j_i (j = j_i), пока (j+2) < длины расширенного массива
            {
                k[j+2] = x[i][j+1]; // в массив k в элемент [j+2] кладем элемент [i][j+1] изначального массива (то есть копируем со сдвигом)
            }

            x[i] = k; // присвоим ссылочной переменной изначального массива ссылку на наш массив k
        }
    }

//метод main
    public static void main(String[] args) {
        int m = 3; // введем перемную m (размерность строк)
        int n = 10; // введем перемную n(размерность столбцов)
        int maxi; // введем перемную maxi (индекс столбца, в котром находится максимальный элемент)
        int a[][] = create(m,n);// вызов метода, создающего двумерный массив
        init(a); // вызов метода, инициализирующего двумерный массив
        print(a); // вызов метода, выводящего двумерный массив
        maxi = maxem(a); // вызов метода, находящего номер столбца (j) максимального элемента массива
        addj(a,maxi); // вызов метода, создающего расширенный массив с дублированным столбцом
        print(a); // вызов метода, выводящего двумерный массив
    }
}